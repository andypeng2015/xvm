- implement timeout for IO operations (interrupt IO executor threads)

- move ecstasy.mgmt package to a separate module

- MapMapping doesn't work for properties that declared as Map classes, e.g.
    const Test(Map<Int, String> map)     - json serialization works
    const Test(HashMap<Int, String> map) - json serialization DOESN'T WORK

- need to implement "persistent" mutators for HasherMap

- improve error description for
    "service S extends Closeable" (extends vs. implements)
    "service S incorporates Closeable" (incorporates vs. implements)
   etc. -- see TypeCompositionStatement.resolveNames()

- should this compile?
    if (ParamType body := request.attributes.getAttribute(HttpAttributes.BODY))

- improve toString() for TypeConstant of function type
    (Function<Tuple<this:Map<Map.Key, Map.Value>.Entry>, Tuple<Boolean>>)

- if not auto-proxy'ed then try to freeze before throwing

- enum ClassCompositions without type parameters could be made into CanonicalCompositions

- add eval command history for the debugger

- entering debugger should stop time

- the XTC compiler disregards "resources" changes if nothing else changed and "-force" option
  is not specified

- add "-version" option to xec command

- add a periodic re-schedule to Timer API

- consider using (new ConcurrentSection()) to get "pre-switching" notification

- compiler to report on ambiguous type parameter name across a virtual child and its parent(s)

- add deadlock detection

- Cam: the last case in the switch should not allow "continue"

- consider not needing the ^ for a return of a tail-call invocation (except in a try block?)
    "return foo();" should be equivalent to "return foo^();"

- consider an automatic conversion from FutureVar<T> to T, for example, instead of (Channel.x):
        @Future Int result = write(buffer);
        &result.thenDo(() -> written(buffer));
        return result;
  one could simply write:
    return write^(buffer).thenDo(() -> written(buffer));

- discuss recursive lambda calls (use this:function?)

- implement boundary checks for atomic integers

- rewrite removeAccess() and removeImmutable(); it blows on virtual children now

- try to get rid of reportNotNewable() by logging at TypeInfo (now we can)

- consider a compiler warning if a return value of Closeable type is ignored (@Adopt annotation)

- consider a new Async mixin:
        mixin Async into Object implements Service {}
  allowing to turn a mutable class into a service:
        ErrorList errs = new @Async ErrorList(10);

- add compiler support for conditional Tuple

- ComponentTemplate equality is not working; how/where to declare it native?
    static <CompileType extends RTComponentTemplate> Boolean equals(CompileType o1, CompileType o2)
        {
        TODO("native");
        }

- override of @Lazy property with a different @Lazy blows

- consider adding a V_GET opcode that would combine the functionality of L_GET and MOVE_THIS for
  dynamically inflated (via & ref) or non-inflated properties; it would eliminated the need for
  corresponding compensation in ClassTemlpate.getPropertyValue() and OpInvocable.getCallChain()
  (submission "Fix Ref handling for non-inflated properties" of 8/9/2022)

- TypeInfo is failing to compute (see NumberArray.asBitArray():
  Var<Bit> v = new Object()
        {
        Bit element
            {
            @Override
            Boolean assigned.get()
                {
                TODO
                }

            @Override
            Bit get()
                {
                TODO
                }

            @Override
            void set(Bit v)
                {
                TODO
                }
            }
        }.&element;

- optimize-out unnecessary array cloning by changing getBytes() to copyBytes(arrayInto)

- consider @Proxyable annotation for compiler to enforce proxy-ability of an interface

// DEFERRED:
- RTFunction should not be xConst
- classes in methods don't support captures of formal types
- @Atomic property with a mutable content needs to wrap
- what if timer.schedule() lambda throws? (exception is invisible)
- infinite loop detection
- long object handle
- upon a Future's gc report if an exception has not been handled